#' Spatial generalized Lotka-Volterra model
#'
#' @param n_species Integer. Number of species
#' @param n_patch Integer. Number of habitat patches
#' @param n_timestep Integer. Number of time step for a simulation run
#' @param interval Numeric. Time interval used for a numerical ODE solver
#' @param r Numeric. Intrinsic growth rates of modeled species
#' @param alpha n_species x n_species interaction matrix
#' @param phi Numeric. Dispersal rate parameter
#' @param connectivity n_patch x n_patch connectivity (adjacency) matrix.
#' @param disturb List. Parameters for disturbance: \code{int} = disturbance intensity; \code{rate} = disturbance frequency; \code{s} = temporal duration of disturbance.
#' @param n0 List. Initial densities for modeled species. Randomly generated by \code{runif(n_species, min = min, max = max)}
#' @param threshold Numeric. Extinction threshold. Species will be removed from a simulation if species density goes below this value
#' @param ... Additional arguments passed to \link{deSolve::ode}
#'
#' @author Akira Terui, \email{hanabi0111@gmail.com}
#'
#' @export

sglv <- function(n_species,
                 n_patch,
                 n_timestep = 100,
                 interval = 0.01,
                 r,
                 alpha,
                 phi,
                 connectivity,
                 disturb = list(int = 1,
                                rate = (1 / n_timestep) * 10,
                                s = interval * 10),
                 n0 = list(min = 0,
                           max = 1),
                 threshold = 1E-4,
                 ...) {

  # verify inputs -----------------------------------------------------------

  # r input
  if (length(r) != 1 && length(r) != n_species)
    stop("r must have length one or n_species")

  # alpha input
  if (!all(dim(alpha) == n_species))
    stop("alpha's dimensions must be n_species x n_species")

  # connectivity input
  if (!all(dim(connectivity) == n_patch))
    stop("connectivity's dimensions must be n_patch x n_patch")

  # disturbance intensity
  if (length(disturb$int) != 1 && length(disturb$int) != n_patch)
    stop("disturbance intensity (int) must have length one or n_patch")

  # disturbance setup -------------------------------------------------------

  # n possible disturbance points
  # + 100 to ensure cumsum(x) > n_timestep
  # remove points > n_timestep
  psi <- with(disturb, cumsum(rexp(n = ceiling((1 / rate) + 100), rate)))
  psi <- psi[psi <= n_timestep]

  # pseudo time steps
  time <- seq(0, n_timestep, by = disturb$s)
  t_psi <- sapply(psi, FUN = function(x) which.min(abs(time - x)))

  # create dummy time-series for signals
  signal <- data.frame(time = time,
                       psi = rep(0, length(time)))
  signal$psi[t_psi] <- 1

  # linear interpolation function
  input <- stats::approxfun(signal, rule = 2)

  # n_patch x n_species disturbance intensity matrix
  ## fun_to_m() returns n_species x n_patch matrix
  ## transpose to n_patch x n_species
  Et <- with(disturb, fun_to_m(int,
                               n_species = n_species,
                               n_patch = n_patch,
                               param_attr = "patch"))

  E <- t(Et$m_x)

  # intrinsic growth --------------------------------------------------------

  if (inherits(r, "matrix")) {

    if (all(dim(r) == c(n_patch, n_species)))
      stop("Dimension mismatch in r; r must be a n_patch x n_species matrix")

    R <- r

  } else {

    Rt <- fun_to_m(r,
                   n_species = n_species,
                   n_patch = n_patch,
                   param_attr = "species")

    R <- t(Rt$m_x)

  }

  # ode ---------------------------------------------------------------------

  # n: n_patch x n_species abundance vector
  # N: n_patch x n_species abundance matrix
  # R: n_patch x n_species growth rate matrix
  # psi: indicator parameter scalar
  # E: n_patch x n_species disturbance intensity matrix
  # A: n_species x n_species interaction matrix
  # phi: migration rate
  # C: n_patch x n_patch connectivity matrix

  deriv <- function(t, n, parms) {
    with(parms, {
      psi <- input(t)
      N <- matrix(n, nrow = n_patch, ncol = n_species)
      dN <- N * (R - psi * E + N %*% A) + phi * C %*% N
      list(dN)
    })
  }

  # define absorbing condition
  ## root function
  rootfun <- function(t, n, parms) {
    return(n - threshold)
  }

  ## extinction: triggered when "n - threshold = 0"
  eventfun <- function(t, n, pars) {
    n <- ifelse(n <= threshold, 0, n)
    return(n)
  }

  # parameter list
  parms <- list(n_species = n_species,
                n_patch = n_patch,
                R = R,
                E = E,
                A = alpha,
                phi = phi,
                C = connectivity)

  # initial values for a state variable
  n_init <- with(n0, stats::runif(n_species * n_patch,
                                  min = min,
                                  max = max))

  # time-series
  times <- seq(0, n_timestep, by = interval)

  # run ode solver
  cout <- deSolve::ode(y = n_init,
                       times = times,
                       func = deriv,
                       parms = parms,
                       events = list(func = eventfun, root = TRUE),
                       rootfun = rootfun,
                       ...)

  return(cout)
}
