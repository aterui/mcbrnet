#' Spatial generalized Lotka-Volterra model
#'
#' @param n_species Integer. Number of species
#' @param n_patch Integer. Number of habitat patches
#' @param n_timestep Integer. Number of time step for a simulation run
#' @param interval Numeric. Time interval used for a numerical ODE solver
#' @param r Numeric. Intrinsic growth rates of modeled species
#' @param alpha n_species x n_species interaction matrix
#' @param dispersal List. This list must contain the following parameters as named elements: \code{adj} n_patch x n_patch adjacency matrix; \code{phi} dispersal rate; \code{m} dispersal mortality rate.
#' @param disturb List. This list must contain the following parameters as named elements: \code{int} disturbance intensity; \code{rate} disturbance frequency; \code{s} scale parameter that controls the duration of disturbance.
#' @param n0 List. Initial densities for modeled species that are randomly generated by \code{runif(n_species, min = min, max = max)}. This list must contain \code{min} and \code{max} as named elements.
#' @param threshold Numeric. Extinction threshold. Species will be removed from a simulation if species density goes below this value
#' @param ... Additional arguments passed to \code{\link{ode}}
#'
#' @author Akira Terui, \email{hanabi0111@gmail.com}
#'
#' @export

sglv <- function(n_species,
                 n_patch,
                 n_timestep = 100,
                 interval = 0.01,
                 r,
                 alpha,
                 dispersal = list(adj = matrix(0,
                                               nrow = n_patch,
                                               ncol = n_patch),
                                  phi = 0,
                                  m = 0),
                 disturb = list(int = 1,
                                rate = (1 / n_timestep) * 10,
                                s = interval * 10),
                 n0 = list(min = 0,
                           max = 1),
                 threshold = 1E-4,
                 ...) {

  # verify inputs -----------------------------------------------------------

  # r input
  if (!inherits(r, "matrix")) {
    if (length(r) != 1 && length(r) != n_species)
      stop("r must have length one or n_species")
  }

  # alpha input
  if (!all(dim(alpha) == n_species))
    stop("alpha's dimensions must be n_species x n_species")

  # dispersal input
  if (!all(sort(names(dispersal)) == sort(c("adj", "phi", "m"))))
    stop("Elements in the dispersal list must be 'adj', 'phi', and 'm'")

  with(dispersal, {
    if (!all(dim(adj) == n_patch))
      stop("adj's dimensions must be n_patch x n_patch")

    if (phi < 0 || m < 0)
      stop("'phi' and 'm' must be >= 0")
  })

  # disturbance input
  if (!all(sort(names(disturb)) == sort(c("int", "rate", "s"))))
    stop("Elements in the dispersal list must be 'int', 'rate', and 's'")

  with(disturb, {
    if (length(int) != 1 && length(int) != n_patch)
      stop("disturbance intensity (int) must have length one or n_patch")

    if (int < 0 || rate < 0 || s < 0)
      stop("'int,' 'rate,' and 's' must be >= 0")
  })

  # n0 input
  if (!all( sort(names(n0)) == sort(c("min", "max"))))
    stop("Elements in the n0 list must be 'min' and 'max'")

  with(n0, {
    if (min < 0 || max < 0 || min > max)
      stop("invalid inputs in n0")
  })

  # disturbance setup -------------------------------------------------------

  # n possible disturbance points
  # + 100 to ensure cumsum(x) > n_timestep
  # remove points > n_timestep
  psi <- with(disturb, cumsum(rexp(n = ceiling((1 / rate) + 100), rate)))
  psi <- psi[psi <= n_timestep]

  # pseudo time steps
  time <- seq(0, n_timestep, by = disturb$s)
  t_psi <- sapply(psi, FUN = function(x) which.min(abs(time - x)))

  # create dummy time-series for signals
  signal <- data.frame(time = time,
                       psi = rep(0, length(time)))
  signal$psi[t_psi] <- 1

  # linear interpolation function
  input <- stats::approxfun(signal, rule = 2)

  # n_patch x n_species disturbance intensity matrix
  ## fun_to_m() returns n_species x n_patch matrix
  ## transpose to n_patch x n_species
  Et <- with(disturb, fun_to_m(int,
                               n_species = n_species,
                               n_patch = n_patch,
                               param_attr = "patch"))

  E <- t(Et$m_x)

  # intrinsic growth --------------------------------------------------------

  if (inherits(r, "matrix")) {

    if (!all(dim(r) == c(n_patch, n_species)))
      stop("Dimension mismatch in r; r must be a n_patch x n_species matrix")

    R <- r

  } else {

    Rt <- fun_to_m(r,
                   n_species = n_species,
                   n_patch = n_patch,
                   param_attr = "species")

    R <- t(Rt$m_x)

  }

  # dispersal ---------------------------------------------------------------

  # pick id of non-zero columns
  C1 <- C0 <- with(dispersal, adj)
  id_nz <- which(colSums(C0) != 0)

  # scale adjacency matrix
  if (length(id_nz) > 0) {

    if (length(id_nz) == 1) {
      x <- sum(C0[, id_nz])
    } else {
      x <- colSums(C0[, id_nz])
    }

    C1[, id_nz] <- t(t(C0[, id_nz]) / x)
  }

  # apply dispersal rate and mortality
  ## C <- (phi - m) * C0: immigration, accounting for disp. mortality by m
  ## diag(C) <- -phi: emigration
  C <- with(dispersal, (phi - m) * C1)
  diag(C) <- with(dispersal, -phi)

  # ode ---------------------------------------------------------------------

  # n: n_patch x n_species abundance vector
  # N: n_patch x n_species abundance matrix
  # R: n_patch x n_species growth rate matrix
  # psi: indicator parameter scalar
  # E: n_patch x n_species disturbance intensity matrix
  # A: n_species x n_species interaction matrix
  # phi: migration rate
  # C: n_patch x n_patch connectivity matrix

  deriv <- function(t, n, parms) {
    with(parms, {
      psi <- input(t)
      N <- matrix(n, nrow = n_patch, ncol = n_species)
      dN <- N * (R - psi * E + N %*% A) + C %*% N
      list(dN)
    })
  }

  # define absorbing condition
  ## root function
  rootfun <- function(t, n, parms) {
    return(n - threshold)
  }

  ## extinction: triggered when "n - threshold = 0"
  eventfun <- function(t, n, pars) {
    n <- ifelse(n <= threshold, 0, n)
    return(n)
  }

  # parameter list
  parms <- with(dispersal,
                list(n_species = n_species,
                     n_patch = n_patch,
                     R = R,
                     E = E,
                     A = alpha,
                     C = C))

  # initial values for a state variable
  n_init <- with(n0, stats::runif(n_species * n_patch,
                                  min = min,
                                  max = max))

  # time-series
  times <- seq(0, n_timestep, by = interval)

  # run ode solver
  cout <- deSolve::ode(y = n_init,
                       times = times,
                       func = deriv,
                       parms = parms,
                       events = list(func = eventfun, root = TRUE),
                       rootfun = rootfun,
                       ...)

  return(cout)
}
